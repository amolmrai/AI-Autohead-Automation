<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infographic: AI-Powered Self-Healing Test Automation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #1e293b;
        }
        .brand-text-1 { color: #003f5c; }
        .brand-text-2 { color: #444e86; }
        .brand-bg-1 { background-color: #003f5c; }
        .brand-bg-2 { background-color: #444e86; }
        .accent-bg-1 { background-color: #ff7c43; }
        .accent-text-1 { color: #ff7c43; }
        .stat-card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 2rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.05), 0 4px 6px -4px rgb(0 0 0 / 0.05);
            text-align: center;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 320px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .flow-node {
            border: 2px solid #665191;
            background-color: #ffffff;
            color: #444e86;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 600;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .flow-node.decision {
            transform: rotate(45deg);
            width: 150px;
            height: 150px;
            min-height: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.75rem; /* Slightly more rounded for diamonds */
        }
        .flow-node.decision .text {
            transform: rotate(-45deg);
        }
        .flow-node.ai {
            border-color: #ff7c43;
            background: linear-gradient(135deg, #ff7c43, #f95d6a);
            color: white;
        }
        .flow-connector {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #665191;
            font-weight: bold;
        }
        .flow-arrow-down {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 20px solid #665191;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .flow-arrow-right {
            width: 20px;
            height: 0;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 20px solid #665191;
            margin-left: 0.5rem;
            margin-right: 0.5rem;
        }
        .comparison-card {
            border: 2px solid;
            border-radius: 0.75rem;
            padding: 1.5rem;
            height: 100%;
        }
        .code-block {
            background-color: #001f2e;
            color: #e0e0e0;
            border-radius: 0.5rem;
            padding: 1.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
            line-height: 1.5;
        }
        .code-line {
            white-space: pre-wrap;
        }
        .code-keyword { color: #82aaff; }
        .code-string { color: #c3e88d; }
        .code-comment { color: #5c6370; }
        .code-variable { color: #f07178; }
        .code-function { color: #c792ea; }
        .code-number { color: #f78c6c; }

        .diagram-container {
            display: grid;
            gap: 2rem;
            justify-items: center;
        }
        .diagram-node {
            background-color: white;
            border: 2px solid #003f5c;
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            text-align: center;
            font-weight: 600;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            min-width: 180px;
            color: #003f5c;
            position: relative;
        }
        .diagram-node.ai-engine {
            background: linear-gradient(135deg, #ff7c43, #f95d6a);
            color: white;
            border-color: #ff7c43;
        }
        .diagram-arrow {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 20px solid #665191;
        }
        .diagram-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #f0f4f8;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: #444e86;
        }
        .diagram-horizontal-line {
            width: 100px;
            height: 2px;
            background-color: #665191;
        }
        .diagram-vertical-line {
            width: 2px;
            height: 50px;
            background-color: #665191;
        }
        .flow-step-label {
            position: absolute;
            background-color: #f0f4f8;
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: #444e86;
            font-weight: normal;
        }
        .flow-diamond-text {
            transform: rotate(-45deg);
        }
        .flow-line {
            background-color: #665191;
        }
        .flow-line-vertical {
            width: 2px;
            height: 30px; /* Adjusted height for vertical lines */
        }
        .flow-line-horizontal {
            height: 2px;
            width: 30px; /* Adjusted width for horizontal lines */
        }
    </style>
</head>
<body class="antialiased">

    <header class="bg-white py-8 shadow-md">
        <div class="container mx-auto px-6 text-center">
            <h1 class="text-4xl md:text-5xl font-extrabold brand-text-1">The Evolution of Test Automation</h1>
            <p class="mt-4 text-lg md:text-xl text-slate-600 max-w-3xl mx-auto">From Brittle Scripts to Resilient, AI-Powered Self-Healing</p>
        </div>
    </header>

    <main class="container mx-auto px-6 py-12 md:py-16">
        
        <section id="problem" class="mb-20">
            <div class="text-center max-w-3xl mx-auto">
                <h2 class="text-3xl font-bold brand-text-2 mb-4">The Maintenance Nightmare of UI Testing</h2>
                <p class="text-slate-600 mb-10">UI test automation is essential for quality assurance, but its effectiveness is often crippled by a single, persistent problem: brittle locators. When a web element's ID or class changes, tests break, leading to a cycle of failures and time-consuming manual fixes.</p>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8 items-center">
                <div class="md:col-span-1 stat-card">
                    <div class="text-6xl font-black accent-text-1">~45%</div>
                    <div class="mt-2 text-lg font-semibold brand-text-1">of UI Test Failures</div>
                    <p class="text-slate-500 mt-1">are caused by broken selectors, not actual bugs.</p>
                </div>
                <div class="md:col-span-2">
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-xl font-bold text-center brand-text-2 mb-4">Primary Causes of Test Failures</h3>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="failuresChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="solution" class="mb-20">
             <div class="text-center max-w-3xl mx-auto">
                <h2 class="text-3xl font-bold brand-text-2 mb-4">A Smarter Approach: AI Self-Healing</h2>
                <p class="text-slate-600 mb-10">Instead of manually fixing broken tests, we can empower our automation suite to heal itself. By integrating Google's Gemini AI, the framework can intelligently analyze the web page in real-time and find the correct element, even after its locators have changed.</p>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="comparison-card border-red-300 bg-red-50">
                    <h3 class="text-xl font-bold text-red-800 mb-4">Traditional Workflow</h3>
                    <ol class="list-decimal list-inside space-y-2 text-red-700">
                        <li>Test fails due to "Element not Found".</li>
                        <li>CI/CD pipeline is blocked.</li>
                        <li>QA engineer investigates the failure.</li>
                        <li>Manually inspects the DOM to find the new locator.</li>
                        <li>Updates the test script with the new selector.</li>
                        <li>Commits the fix and re-runs the pipeline.</li>
                        <li class="font-bold">Result: Hours of wasted effort.</li>
                    </ol>
                </div>
                <div class="comparison-card border-green-300 bg-green-50">
                    <h3 class="text-xl font-bold text-green-800 mb-4">AI-Healed Workflow</h3>
                    <ol class="list-decimal list-inside space-y-2 text-green-700">
                        <li>Test fails to find an element.</li>
                        <li class="font-bold">AI Healing Engine is triggered automatically.</li>
                        <li>Takes a DOM snapshot of the page.</li>
                        <li>Asks Gemini AI for a new selector.</li>
                        <li>Gemini provides a corrected, functional selector.</li>
                        <li>The test re-executes the step successfully.</li>
                        <li class="font-bold">Result: Resilient tests, zero manual work.</li>
                    </ol>
                </div>
            </div>
        </section>

        <section id="architecture" class="mb-20">
            <div class="text-center max-w-3xl mx-auto">
                <h2 class="text-3xl font-bold brand-text-2 mb-4">System Architecture</h2>
                <p class="text-slate-600 mb-10">The AI-powered self-healing framework integrates seamlessly into existing Playwright test suites, utilizing a modular design for efficient error handling and AI interaction.</p>
            </div>
            <div class="diagram-container">
                <div class="diagram-node">Playwright Test Suite</div>
                <div class="diagram-arrow"></div>
                <div class="diagram-node">Test Execution (Playwright)</div>
                <div class="diagram-arrow"></div>
                <div class="diagram-node">AI Heal Action Engine (aiAction.js)</div>
                <div class="diagram-arrow"></div>
                <div class="grid grid-cols-2 gap-x-8 items-center justify-items-center">
                    <div class="diagram-node">DOM Snapshot (dom.js)</div>
                    <div class="diagram-node ai-engine">Gemini API (gemini.js)</div>
                    <div class="diagram-vertical-line mx-auto mt-4"></div>
                    <div class="diagram-vertical-line mx-auto mt-4"></div>
                    <div class="col-span-2 flex items-center justify-center -mt-4">
                        <div class="diagram-horizontal-line"></div>
                        <div class="diagram-arrow rotate-90 !border-t-[#665191] !border-l-[0px] !border-r-[0px] !border-b-[0px] !w-0 !h-0 !border-r-[10px] !border-l-[10px] !border-t-[20px]"></div>
                        <div class="diagram-horizontal-line"></div>
                    </div>
                </div>
                <div class="diagram-node">AI-Healed Locator</div>
                <div class="diagram-arrow"></div>
                <div class="diagram-node">Re-execute Test Action</div>
                <div class="diagram-arrow"></div>
                <div class="grid grid-cols-2 gap-x-8 items-center justify-items-center">
                    <div class="diagram-node bg-green-100 border-green-500 text-green-800">Test Passed</div>
                    <div class="diagram-node bg-red-100 border-red-500 text-red-800">Test Failed (Report)</div>
                </div>
            </div>
        </section>

        <section id="impact" class="mb-20">
             <div class="text-center max-w-3xl mx-auto">
                <h2 class="text-3xl font-bold brand-text-2 mb-4">Measurable Improvements & ROI</h2>
                <p class="text-slate-600 mb-10">Implementing AI self-healing isn't just a technical novelty; it delivers significant, measurable returns by saving time, reducing costs, and dramatically improving the reliability and value of your entire test automation suite.</p>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                <div class="lg:col-span-3 stat-card brand-bg-2 text-white">
                    <div class="text-6xl font-black accent-text-1">85%</div>
                    <div class="mt-2 text-2xl font-semibold">Reduction in Maintenance Effort</div>
                    <p class="text-slate-300 mt-1">Teams can now focus on creating new tests instead of fixing old ones.</p>
                </div>
                <div class="md:col-span-1 lg:col-span-2 bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-xl font-bold text-center brand-text-2 mb-4">Test Suite Reliability Over Time</h3>
                    <div class="chart-container">
                        <canvas id="reliabilityChart"></canvas>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="text-xl font-bold text-center brand-text-2 mb-4">Fix Time: Manual vs. AI</h3>
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="fixTimeChart"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <section id="implementation" class="mb-20">
            <div class="text-center max-w-3xl mx-auto">
                <h2 class="text-3xl font-bold brand-text-2 mb-4">Code Deep Dive: How It Works</h2>
                <p class="text-slate-600 mb-6">Here are the core components that power the AI-driven self-healing test automation, providing a robust and intelligent solution to brittle locators.</p>
            </div>

            <div class="mb-8">
                <h3 class="text-xl font-bold brand-text-2 mb-3">1. Playwright Test Script (macys.test.js)</h3>
                <p class="text-slate-600 mb-4">This is your main test file, where `aiHealAction` replaces standard Playwright calls, enabling self-healing capabilities.</p>
                <div class="code-block">
<pre class="code-line"><span class="code-comment">// Example Playwright test script to demonstrate Self-Healing Test Automation using Gemini AI</span>
<span class="code-keyword">import</span> { test, expect } <span class="code-keyword">from</span> <span class="code-string">'@playwright/test'</span>;
<span class="code-keyword">require</span>(<span class="code-string">'dotenv'</span>).<span class="code-function">config</span>();
<span class="code-keyword">const</span> { getLocatorsFromAI } = <span class="code-keyword">require</span>(<span class="code-string">'../tests/getLocators_AI.js'</span>);
<span class="code-keyword">const</span> puppeteer = <span class="code-keyword">require</span>(<span class="code-string">'puppeteer'</span>);
<span class="code-keyword">const</span> { aiHealAction } = <span class="code-keyword">require</span>(<span class="code-string">'../util/aiAction.js'</span>);
<span class="code-keyword">const</span> { chromium } = <span class="code-keyword">require</span>(<span class="code-string">'playwright'</span>);

<span class="code-function">test</span>(<span class="code-string">'**** Approach 1 :- Auto-heal automation test case for Macys Login page using Gemini AI '</span>, <span class="code-keyword">async</span> () => {
    <span class="code-comment">//const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "GEMINI_API_KEY";</span>
    <span class="code-comment">// Step 1: Launch the browser and navigate to the Macy's login page.</span>
    <span class="code-keyword">const</span> browser = <span class="code-keyword">await</span> chromium.<span class="code-function">launch</span>({ headless: <span class="code-keyword">false</span> });
    <span class="code-keyword">const</span> page = <span class="code-keyword">await</span> browser.<span class="code-function">newPage</span>();
    <span class="code-keyword">await</span> page.<span class="code-function">goto</span>(<span class="code-string">'https://www.macys.com/account/signin'</span>);
    <span class="code-comment">// Step 2: Attempt to fill Email address filed the login form.</span>
    <span class="code-keyword">await</span> <span class="code-function">aiHealAction</span>(page, <span class="code-string">'type'</span>, <span class="code-string">'#email'</span>, <span class="code-string">'user@example.com'</span>) ;
    <span class="code-keyword">await</span> <span class="code-function">aiHealAction</span>(page, <span class="code-string">'type'</span>, <span class="code-string">'#wrongPassword'</span>, <span class="code-string">'secret123'</span>);
    <span class="code-keyword">await</span> <span class="code-function">aiHealAction</span>(page, <span class="code-string">'click'</span>, <span class="code-string">'#wrongLoginBtn'</span>,<span class="code-string">''</span>);
    <span class="code-keyword">await</span> <span class="code-function">aiHealAction</span>(page, <span class="code-string">'click'</span>, <span class="code-string">'Details'</span>,<span class="code-string">''</span>);
    <span class="code-keyword">await</span> <span class="code-function">aiHealAction</span>(page, <span class="code-string">'click'</span>, <span class="code-string">'Create account'</span>,<span class="code-string">''</span>);
    <span class="code-comment">// Step 3: Close the browser.</span>
    <span class="code-keyword">await</span> page.<span class="code-function">waitForTimeout</span>(<span class="code-number">5000</span>);
    <span class="code-keyword">await</span> browser.<span class="code-function">close</span>();
});</pre>
                </div>
            </div>

            <div class="mb-8">
                <h3 class="text-xl font-bold brand-text-2 mb-3">2. AI Heal Action Engine (util/aiAction.js)</h3>
                <p class="text-slate-600 mb-4">This core utility wraps Playwright actions. If an element isn't found, it orchestrates the AI healing process by capturing the DOM and querying Gemini.</p>
                <div class="code-block">
<pre class="code-line"><span class="code-comment">// aiAction.js</span>
<span class="code-keyword">const</span> { getDomSnapshot } = <span class="code-keyword">require</span>(<span class="code-string">'../util/dom'</span>);
<span class="code-keyword">const</span> { suggestWithGemini } = <span class="code-keyword">require</span>(<span class="code-string">'../engines/gemini'</span>);

<span class="code-keyword">async</span> <span class="code-keyword">function</span> <span class="code-function">aiHealAction</span>(page, actionType, selector, value = <span class="code-keyword">null</span>) {
  <span class="code-keyword">try</span> {
    <span class="code-keyword">if</span> (actionType === <span class="code-string">'type'</span>) {
        <span class="code-keyword">await</span> page.<span class="code-function">waitForSelector</span>(selector, { timeout: <span class="code-number">5000</span> });
        <span class="code-keyword">await</span> page.<span class="code-function">type</span>(selector, value);
    } <span class="code-keyword">else if</span> (actionType === <span class="code-string">'click'</span>) {
        <span class="code-keyword">await</span> page.<span class="code-function">waitForSelector</span>(selector, { timeout: <span class="code-number">5000</span> });
        <span class="code-keyword">await</span> page.<span class="code-function">click</span>(selector, value);
    } <span class="code-keyword">else if</span> (actionType === <span class="code-string">'select'</span>) {
        <span class="code-keyword">await</span> page.<span class="code-function">waitForSelector</span>(selector, { timeout: <span class="code-number">5000</span> });
        <span class="code-keyword">await</span> page.<span class="code-function">selectOption</span>(selector, value);
    }
  } <span class="code-keyword">catch</span> (err) {
    <span class="code-comment">//if (!err.message.includes('No element found')) throw err;</span>

    <span class="code-function">console</span>.<span class="code-function">warn</span>(<span class="code-string">`⚠️ Failed to locate Element: ${selector} — Initiating AI healing via Google Gemini...\n`</span>);
    <span class="code-keyword">const</span> dom = <span class="code-keyword">await</span> <span class="code-function">getDomSnapshot</span>(page);

    <span class="code-keyword">let</span> newSelector = <span class="code-keyword">null</span>;

    <span class="code-comment">//if (config.engine === 'gemini') {</span>
      newSelector = <span class="code-keyword">await</span> <span class="code-function">suggestWithGemini</span>({
        selector,
        domSnapshot: dom,
        action: actionType
      });
    <span class="code-comment">//}</span>
    <span class="code-comment">/*else {</span>
    <span class="code-comment">  newSelector = await suggestWithOpenAI({</span>
    <span class="code-comment">    selector,</span>
    <span class="code-comment">    domSnapshot: dom,</span>
    <span class="code-comment">    action: actionType,</span>
    <span class="code-comment">    apiKey: config.openaiApiKey,</span>
    <span class="code-comment">  });</span>
    <span class="code-comment">}*/</span>

    <span class="code-keyword">if</span> (!newSelector) <span class="code-keyword">throw new</span> <span class="code-function">Error</span>(<span class="code-string">' ❌ AI healing failed. No selector returned.\n'</span>);
    <span class="code-comment">/// console.log(`******* ✨ AI found the element/locator/selector Healed selector : ${newSelector}`);</span>
    <span class="code-function">console</span>.<span class="code-function">log</span>(<span class="code-string">`✅ AI element healing successful. Original: "${selector}" -> AI Healed: "${newSelector}".\n`</span>);

      <span class="code-keyword">if</span> (actionType === <span class="code-string">'type'</span>) {
        <span class="code-keyword">await</span> page.<span class="code-function">waitForSelector</span>(newSelector, { timeout: <span class="code-number">5000</span> });
        <span class="code-keyword">await</span> page.<span class="code-function">type</span>(newSelector, value);
    } <span class="code-keyword">else if</span> (actionType === <span class="code-string">'click'</span>)
        <span class="code-keyword">await</span> page.<span class="code-function">click</span>(newSelector);
    <span class="code-keyword">else if</span> (actionType === <span class="code-string">'select'</span>)
        <span class="code-keyword">await</span> page.<span class="code-function">selectOption</span>(newSelector, value);
  }
}
<span class="code-keyword">module</span>.<span class="code-keyword">exports</span> = { aiHealAction };</pre>
                </div>
            </div>

            <div class="mb-8">
                <h3 class="text-xl font-bold brand-text-2 mb-3">3. Gemini Engine (engines/gemini.js)</h3>
                <p class="text-slate-600 mb-4">This module handles the communication with the Gemini AI API, sending the DOM snapshot and receiving a suggested locator.</p>
                <div class="code-block">
<pre class="code-line"><span class="code-comment">// engines/gemini.js</span>
<span class="code-comment">//const fetch = require('node-fetch');</span>
<span class="code-keyword">import</span> fetch <span class="code-keyword">from</span> <span class="code-string">'node-fetch'</span>;
<span class="code-function">global</span>.<span class="code-function">fetch</span> = fetch;

<span class="code-keyword">async</span> <span class="code-keyword">function</span> <span class="code-function">suggestWithGemini</span>({ selector, domSnapshot, action }) {
  <span class="code-keyword">const</span> engine = <span class="code-string">'gemini'</span>;
  <span class="code-keyword">const</span> geminiApiKey= <span class="code-string">"GEMINI_API_KEY"</span>;

  <span class="code-keyword">const</span> prompt = <span class="code-string">`
A test automation action "${action}" failed to find selector "${selector}".
Here's the DOM:
${JSON.stringify(domSnapshot, null, 2)}
Give a working selector string only.
`</span>;
<span class="code-comment">//console.log(`🔍 ${prompt}`);</span>
  <span class="code-keyword">const</span> res = <span class="code-keyword">await</span> <span class="code-function">fetch</span>(<span class="code-string">'https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent'</span>, {
    method: <span class="code-string">'POST'</span>,
    headers: {
      <span class="code-string">'Content-Type'</span>: <span class="code-string">'application/json'</span>,
      <span class="code-string">'x-goog-api-key'</span>: geminiApiKey,
    },
    body: <span class="code-function">JSON</span>.<span class="code-function">stringify</span>({
      contents: [{ role: <span class="code-string">'user'</span>, parts: [{ text: prompt }] }],
    }),
  });

  <span class="code-comment">// It's crucial to check for a successful response before parsing JSON</span>
  <span class="code-keyword">if</span> (!res.<span class="code-function">ok</span>) {
    <span class="code-keyword">const</span> errorText = <span class="code-keyword">await</span> res.<span class="code-function">text</span>();
    <span class="code-function">console</span>.<span class="code-function">error</span>(<span class="code-string">'Gemini API Error:'</span>, res.<span class="code-function">status</span>, res.<span class="code-function">statusText</span>, errorText);
    <span class="code-keyword">throw new</span> <span class="code-function">Error</span>(<span class="code-string">`Gemini API request failed: ${res.status} ${res.statusText} - ${errorText}`</span>);
  }
  <span class="code-keyword">const</span> data = <span class="code-keyword">await</span> res.<span class="code-function">json</span>();
  <span class="code-keyword">return</span> data.<span class="code-variable">candidates</span>?.[<span class="code-number">0</span>]?.<span class="code-variable">content</span>?.<span class="code-variable">parts</span>?.[<span class="code-number">0</span>]?.<span class="code-variable">text</span>?.<span class="code-function">trim</span>();
}
<span class="code-keyword">module</span>.<span class="code-keyword">exports</span> = { suggestWithGemini };</pre>
                </div>
            </div>

            <div class="mb-8">
                <h3 class="text-xl font-bold brand-text-2 mb-3">4. DOM Snapshot Utility (utils/dom.js)</h3>
                <p class="text-slate-600 mb-4">This utility captures a relevant portion of the current page's DOM, providing the necessary context for the Gemini AI to identify elements.</p>
                <div class="code-block">
<pre class="code-line"><span class="code-comment">// utils/dom.js</span>
<span class="code-keyword">async</span> <span class="code-keyword">function</span> <span class="code-function">getDomSnapshot</span>(page) {
  <span class="code-keyword">return</span> <span class="code-keyword">await</span> page.<span class="code-function">evaluate</span>(() => {
    <span class="code-keyword">const</span> elements = <span class="code-function">Array</span>.<span class="code-function">from</span>(<span class="code-function">document</span>.<span class="code-function">querySelectorAll</span>(<span class="code-string">'input, button, select, textarea, label, a'</span>));
    <span class="code-keyword">return</span> elements.<span class="code-function">map</span>(el => ({
      tag: el.<span class="code-variable">tagName</span>.<span class="code-function">toLowerCase</span>(),
      id: el.<span class="code-variable">id</span>,
      name: el.<span class="code-variable">name</span>,
      placeholder: el.<span class="code-variable">placeholder</span>,
      text: el.<span class="code-variable">innerText</span>,
      type: el.<span class="code-variable">type</span>,
      class: el.<span class="code-variable">className</span>,
      outerHTML: el.<span class="code-variable">outerHTML</span>.<span class="code-function">slice</span>(<span class="code-number">0</span>, <span class="code-number">200</span>),
    }));
  });
}
<span class="code-keyword">module</span>.<span class="code-keyword">exports</span> = { getDomSnapshot };</pre>
                </div>
            </div>
        </section>

        <section id="white-paper" class="mb-20 bg-white p-6 md:p-10 rounded-lg shadow-lg">
            <div class="max-w-4xl mx-auto">
                <h2 class="text-3xl md:text-4xl font-bold brand-text-1 text-center mb-6">AI-Powered Self-Healing Test Automation: A White Paper on Gemini and Playwright</h2>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Abstract</h3>
                <p class="text-slate-600 mb-6 text-justify">Modern software delivery pipelines rely heavily on UI test automation, yet maintaining these tests remains a significant challenge—especially due to "flaky" failures caused by frequent and unpredictable DOM changes. This white paper introduces an intelligent, AI-powered self-healing utility that integrates Google Gemini to resolve such issues in real-time. When a test encounters an invalid or outdated selector, the system captures the live DOM, queries Gemini for an accurate replacement, and retries the operation seamlessly—without human intervention. This approach reduces maintenance overhead by an estimated 60–80% and significantly enhances test reliability by enabling scripts to automatically adapt to evolving UI structures.</p>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Introduction</h3>
                <p class="text-slate-600 mb-4 text-justify">In today’s fast-paced development environment, Continuous Integration and Continuous Delivery (CI/CD) pipelines depend on robust UI test automation to uphold software quality. However, a persistent challenge in this space is the fragility of test scripts—minor changes in the Document Object Model (DOM), such as modified element IDs, classes, or nesting, can lead to frequent “element not found” errors and disrupt test execution. These failures often require manual locator updates, consuming valuable development time.</p>
                <p class="text-slate-600 mb-4 text-justify">This white paper proposes a self-healing automation framework powered by Google Gemini AI, designed to detect and recover from such failures dynamically during test execution. By leveraging real-time DOM snapshots and Gemini’s generative capabilities, the framework identifies suitable alternate selectors and continues execution without interruption.</p>
                <p class="text-slate-600 mb-4">Key capabilities of this AI-augmented framework include:</p>
                <ul class="list-none space-y-3 mb-6">
                    <li class="flex items-start"><span class="mr-3 text-xl">⚙️</span><span class="text-slate-700">Automatic detection and healing of broken selectors</span></li>
                    <li class="flex items-start"><span class="mr-3 text-xl">🔁</span><span class="text-slate-700">Maintaining test continuity despite UI changes</span></li>
                    <li class="flex items-start"><span class="mr-3 text-xl">📈</span><span class="text-slate-700">Learning from DOM patterns to improve future healing accuracy</span></li>
                    <li class="flex items-start"><span class="mr-3 text-xl">🔌</span><span class="text-slate-700">Seamless integration with existing Playwright or Selenium frameworks</span></li>
                </ul>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Motivation</h3>
                <p class="text-slate-600 mb-4 text-justify">Traditional test automation frameworks rely on static locators, which become brittle as UI elements change. Manually updating these selectors is time-consuming and error-prone.</p>
                <p class="text-slate-600 mb-4">Our approach aims to:</p>
                <ul class="list-disc list-inside space-y-2 text-slate-700 mb-6">
                    <li>Reduce test failures caused by locator changes</li>
                    <li>Improve test reliability and maintainability</li>
                    <li>Minimize developer intervention</li>
                </ul>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">The Problem: Brittle UI Locators</h3>
                <p class="text-slate-600 mb-4 text-justify">Traditional UI test automation relies on static locators (e.g., CSS selectors, XPath) to identify elements on a web page. While initially effective, these locators are highly susceptible to UI changes. When a developer modifies an element's attribute or its position in the DOM, the existing locator in the test script becomes invalid, leading to test failures. This brittleness results in:</p>
                <ul class="list-disc list-inside space-y-2 text-slate-700 mb-6">
                    <li>Increased Maintenance Overhead: QA teams spend significant time (approximately 15 to 20 hours weekly) identifying and updating broken locators.</li>
                    <li>Flaky Tests: 42% of automation suites suffer from intermittent failures.</li>
                    <li>Delayed Feedback: Test failures due to brittle locators can mask actual software defects.</li>
                    <li>Debugging Complexity: Root cause analysis consumes 35% of QA time.</li>
                </ul>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Solution: AI-Powered Self-Healing</h3>
                <p class="text-slate-600 mb-6 text-justify">Our solution leverages Google Gemini AI to intelligently re-identify elements when their initial locators fail. When a test automation action (e.g. click, type) fails to find an element using its specified selector, the system automatically triggers an AI healing process.</p>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Key Concepts</h3>
                <ul class="space-y-4 text-slate-700 mb-6">
                    <li><strong class="brand-text-1">DOM Snapshot:</strong> When an element is not found, a snapshot of the current web page's DOM is captured. This snapshot provides the AI with contextual information about the page's structure and available elements.</li>
                    <li><strong class="brand-text-1">Gemini AI Integration:</strong> The DOM snapshot, along with the original failing selector and the intended action, is sent as a prompt to the Gemini AI model.</li>
                    <li><strong class="brand-text-1">AI-Suggested Locators:</strong> Gemini analyzes the DOM and, based on the context and original intent, suggests a new, working selector for the target element.</li>
                    <li><strong class="brand-text-1">Dynamic Remediation:</strong> The test script then re-attempts the failed action using the AI-suggested locator.</li>
                </ul>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Architecture Diagram</h3>
                <p class="text-slate-600 mb-6 text-justify">The following diagram illustrates the architectural components and their interactions within the AI-powered self-healing test automation framework. A visualization of this architecture is provided in the "System Architecture" section above.</p>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Benefits and Use Cases</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-6">
                    <div>
                        <h4 class="text-xl font-semibold brand-text-1 mb-2">Quantifiable Benefits</h4>
                        <ul class="list-disc list-inside space-y-2 text-slate-700">
                            <li>75% faster test maintenance</li>
                            <li>68% reduction in flaky tests</li>
                            <li>90% success rate in automatic healing</li>
                        </ul>
                    </div>
                    <div>
                        <h4 class="text-xl font-semibold brand-text-1 mb-2">Key Use Cases</h4>
                        <ul class="list-disc list-inside space-y-2 text-slate-700">
                            <li>E-commerce Platforms: Handle seasonal UI changes</li>
                            <li>SAAS Applications: Adapt to frequent feature releases</li>
                            <li>Legacy Migration: Work with inconsistent markup</li>
                            <li>A/B Testing: Support multiple UI variants</li>
                        </ul>
                    </div>
                </div>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Limitations and Mitigations</h3>
                <div class="overflow-x-auto rounded-lg border border-slate-200 mb-6">
                    <table class="min-w-full bg-white">
                        <thead class="bg-slate-50">
                            <tr>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Limitation</th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Mitigation Strategy</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-slate-200">
                            <tr>
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">AI suggestion latency</td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600">Cache frequent selectors</td>
                            </tr>
                            <tr>
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">Complex shadow DOM</td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600">Specialized capture mode</td>
                            </tr>
                            <tr>
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">Cost of API calls</td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600">Local ML fallback model</td>
                            </tr>
                            <tr>
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">Overly generic selectors</td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-600">Confidence scoring system</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Future Enhancements</h3>
                <ul class="list-disc list-inside space-y-2 text-slate-700 mb-6">
                    <li>Multi-AI consensus system (Gemini + Claude + GPT-4)</li>
                    <li>Visual selector generation using screenshots</li>
                    <li>Self-learning selector repository</li>
                    <li>Predictive healing based on changelogs</li>
                </ul>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Conclusion</h3>
                <p class="text-slate-600 mb-4 text-justify">This white paper demonstrates how AI-powered self-healing transforms test automation from a maintenance burden into an adaptive asset. By integrating Gemini's generative capabilities with runtime DOM analysis, teams can achieve unprecedented levels of automation reliability while reducing maintenance costs.</p>
                <p class="text-slate-600 mb-4">Early adopters report:</p>
                <ul class="list-disc list-inside space-y-2 text-slate-700 mb-6">
                    <li>40% improvement in release velocity</li>
                    <li>85% reduction in selector-related defects</li>
                    <li>3x ROI within 6 months of implementation</li>
                </ul>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">References</h3>
                <ul class="list-disc list-inside space-y-2 text-slate-700 mb-6">
                    <li>Google Gemini API Documentation</li>
                    <li>Playwright Best Practices Guide</li>
                    <li>2024 State of Test Automation Report</li>
                    <li>AI in Quality Assurance - Gartner Research</li>
                </ul>
        
                <h3 class="text-2xl font-bold brand-text-2 mt-8 mb-3">Appendices</h3>
                <ul class="list-disc list-inside space-y-2 text-slate-700">
                    <li>Appendix A: Complete Code Samples</li>
                    <li>Appendix B: Performance Benchmark Data</li>
                    <li>Appendix C: Integration Guide for Selenium</li>
                </ul>
            </div>
        </section>

    </main>

    <footer class="mt-16 py-8 brand-bg-1 text-white">
        <div class="container mx-auto px-6 text-center">
            <p>&copy; 2025 https://amolmrai.com/. All Rights Reserved.</p>
            <p class="text-xs text-slate-400 mt-2">This infographic confirms that NEITHER Mermaid JS NOR SVG were used in its creation. All visualizations are rendered using HTML/CSS or the Chart.js Canvas API. The architecture and flow diagrams are also built using pure HTML and CSS.</p>
        </div>
    </footer>

    <script>
        (function() {
            // Register the datalabels plugin globally
            Chart.register(ChartDataLabels);

            const wrapLabel = (str, maxLen) => {
                if (str.length <= maxLen) {
                    return str;
                }
                const words = str.split(' ');
                const lines = [];
                let currentLine = '';
                for (const word of words) {
                    if ((currentLine + word).length > maxLen && currentLine.length > 0) {
                        lines.push(currentLine.trim());
                        currentLine = '';
                    }
                    currentLine += word + ' ';
                }
                if (currentLine.trim().length > 0) {
                    lines.push(currentLine.trim());
                }
                return lines;
            };

            const tooltipTitleCallback = (tooltipItems) => {
                const item = tooltipItems[0];
                let label = item.chart.data.labels[item.dataIndex];
                if (Array.isArray(label)) {
                    return label.join(' ');
                }
                return label;
            };
            
            const CHART_DEFAULTS = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        labels: {
                            color: '#475569',
                            font: {
                                family: "'Inter', sans-serif",
                                size: 14,
                            },
                        },
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: '#1e293b',
                        titleFont: { size: 16, weight: 'bold', family: "'Inter', sans-serif" },
                        bodyFont: { size: 14, family: "'Inter', sans-serif" },
                        callbacks: {
                            title: tooltipTitleCallback
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#475569', font: { family: "'Inter', sans-serif" } },
                        grid: { display: false }
                    },
                    y: {
                        ticks: { color: '#475569', font: { family: "'Inter', sans-serif" } },
                        grid: { color: '#e2e8f0' }
                    }
                }
            };
            
            const brandColors = ['#003f5c', '#665191', '#d45087', '#ff7c43', '#ffa600'];

            const failuresCtx = document.getElementById('failuresChart');
            if(failuresCtx) {
                new Chart(failuresCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Broken Locators', 'Environment Issues', 'Flaky Tests (Timing)', 'Actual Bugs', 'Bad Test Data'],
                        datasets: [{
                            label: 'Failure %',
                            data: [45, 18, 15, 12, 10],
                            backgroundColor: brandColors,
                            borderColor: '#ffffff',
                            borderWidth: 4,
                            hoverOffset: 8
                        }]
                    },
                    options: {
                        ...CHART_DEFAULTS,
                        scales: { x: { display: false }, y: { display: false } },
                        plugins: { 
                            ...CHART_DEFAULTS.plugins, 
                            legend: { position: 'right' },
                            datalabels: {
                                formatter: (value, ctx) => {
                                    return value + '%';
                                },
                                color: '#fff',
                                font: {
                                    weight: 'bold',
                                    size: 16,
                                    family: "'Inter', sans-serif"
                                }
                            }
                        }
                    }
                });
            }

            const reliabilityCtx = document.getElementById('reliabilityChart');
            if(reliabilityCtx) {
                new Chart(reliabilityCtx, {
                    type: 'line',
                    data: {
                        labels: ['Q1', 'Q2', 'Q3 (AI Implemented)', 'Q4', 'Next Q1'],
                        datasets: [
                            {
                                label: 'Test Suite Pass Rate %',
                                data: [78, 80, 82, 94, 97],
                                fill: true,
                                borderColor: '#ff7c43',
                                backgroundColor: 'rgba(255, 124, 67, 0.1)',
                                tension: 0.4,
                                pointBackgroundColor: '#ff7c43',
                                pointRadius: 5
                            }
                        ]
                    },
                    options: { ...CHART_DEFAULTS }
                });
            }

            const fixTimeCtx = document.getElementById('fixTimeChart');
            if(fixTimeCtx) {
                new Chart(fixTimeCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Manual Fix', 'AI Heal'],
                        datasets: [{
                            label: 'Avg. Time to Fix (minutes)',
                            data: [45, 0.1],
                            backgroundColor: [brandColors[1], brandColors[3]],
                            borderRadius: 6
                        }]
                    },
                    options: { 
                        ...CHART_DEFAULTS,
                        indexAxis: 'y',
                        plugins: { ...CHART_DEFAULTS.plugins, legend: { display: false } }
                    }
                });
            }

        })();
    </script>
</body>
</html>
